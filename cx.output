Terminals unused in grammar

   BREAK
   CONTINUE
   CHARACTER


Rules useless in parser due to conflicts

   16 $@3: /* empty */


State 6 conflicts: 1 shift/reduce
State 17 conflicts: 1 shift/reduce
State 79 conflicts: 1 shift/reduce
State 144 conflicts: 1 shift/reduce
State 175 conflicts: 2 reduce/reduce
State 217 conflicts: 1 shift/reduce


Grammar

    0 $accept: program $end

    1 program: block

    2 @1: /* empty */

    3 $@2: /* empty */

    4 block: LBRACE @1 decls $@2 procdecls stmts RBRACE

    5 decls: decls decl
    6      | /* empty */

    7 decl: type varlist SEMICOLON
    8     | type varlist
    9     | CONST type IDENT BECOMES NUMBER SEMICOLON
   10     | CONST type IDENT BECOMES trueorfalse SEMICOLON
   11     | error SEMICOLON

   12 type: INT
   13     | BOOL

   14 varlist: vardef
   15        | varlist COMMA vardef

   16 $@3: /* empty */

   17 varlist: error $@3 SEMICOLON

   18 vardef: IDENT
   19       | error SEMICOLON

   20 procdecls: /* empty */
   21          | procdecls procdecl

   22 $@4: /* empty */

   23 procdecl: PROC IDENT LPAREN RPAREN get_cx $@4 procbody get_cx

   24 $@5: /* empty */

   25 $@6: /* empty */

   26 $@7: /* empty */

   27 $@8: /* empty */

   28 procbody: LBRACE inc_level $@5 get_table_addr decls $@6 stmts $@7 RBRACE $@8 dec_level

   29 stmts: stmts stm
   30      | /* empty */

   31 stm: ident BECOMES aexpr SEMICOLON
   32    | ident BECOMES trueorfalse SEMICOLON

   33 $@9: /* empty */

   34 stm: READ ident $@9 SEMICOLON

   35 $@10: /* empty */

   36 stm: WRITE aexpr $@10 SEMICOLON

   37 $@11: /* empty */

   38 stm: IF LPAREN bexpr RPAREN get_cx $@11 stm elsestm

   39 $@12: /* empty */

   40 stm: WHILE get_cx LPAREN bexpr RPAREN get_cx $@12 stm
   41    | REPEAT get_cx stm UNTIL LPAREN bexpr RPAREN get_cx SEMICOLON

   42 $@13: /* empty */

   43 stm: DO get_cx stm get_cx WHILE LPAREN bexpr get_cx $@13 RPAREN SEMICOLON
   44    | switchstm

   45 $@14: /* empty */

   46 $@15: /* empty */

   47 $@16: /* empty */

   48 stm: FOR LPAREN fordecl get_cx forbexpr $@14 SEMICOLON get_cx $@15 get_cx forstm RPAREN $@16 get_cx stm
   49    | EXIT NUMBER SEMICOLON
   50    | aselfaddorminus SEMICOLON
   51    | blockstm
   52    | callstm

   53 $@17: /* empty */

   54 stm: error $@17 SEMICOLON

   55 callstm: CALL ident SEMICOLON

   56 $@18: /* empty */

   57 $@19: /* empty */

   58 $@20: /* empty */

   59 $@21: /* empty */

   60 blockstm: LBRACE inc_level $@18 decls $@19 stmts $@20 RBRACE $@21 dec_level

   61 fordecl: /* empty */
   62        | ident BECOMES aexpr SEMICOLON
   63        | ident BECOMES bexpr SEMICOLON

   64 forstm: /* empty */
   65       | aexpr

   66 forbexpr: /* empty */
   67         | bexpr

   68 elsestm: /* empty */

   69 $@22: /* empty */

   70 elsestm: ELSE get_cx $@22 stm

   71 $@23: /* empty */

   72 switchstm: SWITCH get_cx $@23 LPAREN aexpr RPAREN LBRACE casestms defaultstm RBRACE

   73 casestms: /* empty */
   74         | casestms casestm

   75 $@24: /* empty */

   76 casestm: CASE aexpr get_cx $@24 COLON stm

   77 defaultstm: DEFAULT COLON get_cx stm

   78 bexpr: bexpr OR bterm
   79      | bterm

   80 bterm: bterm AND bfactor
   81      | bfactor

   82 bfactor: ident
   83        | trueorfalse
   84        | NOT bfactor
   85        | LPAREN bexpr RPAREN
   86        | ODD LPAREN idornum RPAREN
   87        | rel

   88 rel: idornum EQL aexpr
   89    | idornum NEQ aexpr
   90    | idornum LES aexpr
   91    | idornum LEQ aexpr
   92    | idornum GTR aexpr
   93    | idornum GEQ aexpr

   94 idornum: ident
   95        | NUMBER

   96 trueorfalse: SYM_TRUE
   97            | SYM_FALSE

   98 aexpr: PLUS aterm
   99      | MINUS aterm
  100      | aterm
  101      | aexpr PLUS aterm
  102      | aexpr MINUS aterm

  103 aterm: afactor
  104      | aterm TIMES afactor
  105      | aterm SLASH afactor
  106      | aterm MOD afactor

  107 afactor: abasic
  108        | afactor XOR abasic

  109 abasic: idornum
  110       | LPAREN aexpr RPAREN
  111       | aselfaddorminus

  112 aselfaddorminus: ident SELFADD
  113                | ident SELFMINUS

  114 ident: IDENT

  115 get_cx: /* empty */

  116 get_table_addr: /* empty */

  117 inc_level: /* empty */

  118 dec_level: /* empty */


Terminals, with rules where they appear

$end (0) 0
error (256) 11 17 19 54
INT (258) 12
BOOL (259) 13
IF (260) 38
ELSE (261) 70
WHILE (262) 40 43
WRITE (263) 36
READ (264) 34
CALL (265) 55
PROC (266) 23
PLUS (267) 98 101
MINUS (268) 99 102
TIMES (269) 104
SLASH (270) 105
LES (271) 90
LEQ (272) 91
GTR (273) 92
GEQ (274) 93
EQL (275) 88
NEQ (276) 89
BECOMES (277) 9 10 31 32 62 63
COMMA (278) 15
OR (279) 78
AND (280) 80
NOT (281) 84
SEMICOLON (282) 7 9 10 11 17 19 31 32 34 36 41 43 48 49 50 54 55 62
    63
LPAREN (283) 23 38 40 41 43 48 72 85 86 110
RPAREN (284) 23 38 40 41 43 48 72 85 86 110
LBRACE (285) 4 28 60 72
RBRACE (286) 4 28 60 72
SYM_TRUE (287) 96
SYM_FALSE (288) 97
REPEAT (289) 41
UNTIL (290) 41
XOR (291) 108
CASE (292) 76
SWITCH (293) 72
DEFAULT (294) 77
BREAK (295)
COLON (296) 76 77
CONST (297) 9 10
EXIT (298) 49
CONTINUE (299)
FOR (300) 48
DO (301) 43
MOD (302) 106
ODD (303) 86
SELFADD (304) 112
SELFMINUS (305) 113
IDENT (306) 9 10 18 23 114
NUMBER (307) 9 49 95
CHARACTER (308)
IFX (309)


Nonterminals, with rules where they appear

$accept (55)
    on left: 0
program (56)
    on left: 1, on right: 0
block (57)
    on left: 4, on right: 1
@1 (58)
    on left: 2, on right: 4
$@2 (59)
    on left: 3, on right: 4
decls (60)
    on left: 5 6, on right: 4 5 28 60
decl (61)
    on left: 7 8 9 10 11, on right: 5
type (62)
    on left: 12 13, on right: 7 8 9 10
varlist (63)
    on left: 14 15 17, on right: 7 8 15
$@3 (64)
    on left: 16, on right: 17
vardef (65)
    on left: 18 19, on right: 14 15
procdecls (66)
    on left: 20 21, on right: 4 21
procdecl (67)
    on left: 23, on right: 21
$@4 (68)
    on left: 22, on right: 23
procbody (69)
    on left: 28, on right: 23
$@5 (70)
    on left: 24, on right: 28
$@6 (71)
    on left: 25, on right: 28
$@7 (72)
    on left: 26, on right: 28
$@8 (73)
    on left: 27, on right: 28
stmts (74)
    on left: 29 30, on right: 4 28 29 60
stm (75)
    on left: 31 32 34 36 38 40 41 43 44 48 49 50 51 52 54, on right:
    29 38 40 41 43 48 70 76 77
$@9 (76)
    on left: 33, on right: 34
$@10 (77)
    on left: 35, on right: 36
$@11 (78)
    on left: 37, on right: 38
$@12 (79)
    on left: 39, on right: 40
$@13 (80)
    on left: 42, on right: 43
$@14 (81)
    on left: 45, on right: 48
$@15 (82)
    on left: 46, on right: 48
$@16 (83)
    on left: 47, on right: 48
$@17 (84)
    on left: 53, on right: 54
callstm (85)
    on left: 55, on right: 52
blockstm (86)
    on left: 60, on right: 51
$@18 (87)
    on left: 56, on right: 60
$@19 (88)
    on left: 57, on right: 60
$@20 (89)
    on left: 58, on right: 60
$@21 (90)
    on left: 59, on right: 60
fordecl (91)
    on left: 61 62 63, on right: 48
forstm (92)
    on left: 64 65, on right: 48
forbexpr (93)
    on left: 66 67, on right: 48
elsestm (94)
    on left: 68 70, on right: 38
$@22 (95)
    on left: 69, on right: 70
switchstm (96)
    on left: 72, on right: 44
$@23 (97)
    on left: 71, on right: 72
casestms (98)
    on left: 73 74, on right: 72 74
casestm (99)
    on left: 76, on right: 74
$@24 (100)
    on left: 75, on right: 76
defaultstm (101)
    on left: 77, on right: 72
bexpr (102)
    on left: 78 79, on right: 38 40 41 43 63 67 78 85
bterm (103)
    on left: 80 81, on right: 78 79 80
bfactor (104)
    on left: 82 83 84 85 86 87, on right: 80 81 84
rel (105)
    on left: 88 89 90 91 92 93, on right: 87
idornum (106)
    on left: 94 95, on right: 86 88 89 90 91 92 93 109
trueorfalse (107)
    on left: 96 97, on right: 10 32 83
aexpr (108)
    on left: 98 99 100 101 102, on right: 31 36 62 65 72 76 88 89 90
    91 92 93 101 102 110
aterm (109)
    on left: 103 104 105 106, on right: 98 99 100 101 102 104 105 106
afactor (110)
    on left: 107 108, on right: 103 104 105 106 108
abasic (111)
    on left: 109 110 111, on right: 107 108
aselfaddorminus (112)
    on left: 112 113, on right: 50 111
ident (113)
    on left: 114, on right: 31 32 34 55 62 63 82 94 112 113
get_cx (114)
    on left: 115, on right: 23 38 40 41 43 48 70 72 76 77
get_table_addr (115)
    on left: 116, on right: 28
inc_level (116)
    on left: 117, on right: 28 60
dec_level (117)
    on left: 118, on right: 28 60


State 0

    0 $accept: . program $end

    LBRACE  shift, and go to state 1

    program  go to state 2
    block    go to state 3


State 1

    4 block: LBRACE . @1 decls $@2 procdecls stmts RBRACE

    $default  reduce using rule 2 (@1)

    @1  go to state 4


State 2

    0 $accept: program . $end

    $end  shift, and go to state 5


State 3

    1 program: block .

    $default  reduce using rule 1 (program)


State 4

    4 block: LBRACE @1 . decls $@2 procdecls stmts RBRACE

    $default  reduce using rule 6 (decls)

    decls  go to state 6


State 5

    0 $accept: program $end .

    $default  accept


State 6

    4 block: LBRACE @1 decls . $@2 procdecls stmts RBRACE
    5 decls: decls . decl

    error  shift, and go to state 7
    INT    shift, and go to state 8
    BOOL   shift, and go to state 9
    CONST  shift, and go to state 10

    error   [reduce using rule 3 ($@2)]
    IF      reduce using rule 3 ($@2)
    WHILE   reduce using rule 3 ($@2)
    WRITE   reduce using rule 3 ($@2)
    READ    reduce using rule 3 ($@2)
    CALL    reduce using rule 3 ($@2)
    PROC    reduce using rule 3 ($@2)
    LBRACE  reduce using rule 3 ($@2)
    RBRACE  reduce using rule 3 ($@2)
    REPEAT  reduce using rule 3 ($@2)
    SWITCH  reduce using rule 3 ($@2)
    EXIT    reduce using rule 3 ($@2)
    FOR     reduce using rule 3 ($@2)
    DO      reduce using rule 3 ($@2)
    IDENT   reduce using rule 3 ($@2)

    $@2   go to state 11
    decl  go to state 12
    type  go to state 13


State 7

   11 decl: error . SEMICOLON

    SEMICOLON  shift, and go to state 14


State 8

   12 type: INT .

    $default  reduce using rule 12 (type)


State 9

   13 type: BOOL .

    $default  reduce using rule 13 (type)


State 10

    9 decl: CONST . type IDENT BECOMES NUMBER SEMICOLON
   10     | CONST . type IDENT BECOMES trueorfalse SEMICOLON

    INT   shift, and go to state 8
    BOOL  shift, and go to state 9

    type  go to state 15


State 11

    4 block: LBRACE @1 decls $@2 . procdecls stmts RBRACE

    $default  reduce using rule 20 (procdecls)

    procdecls  go to state 16


State 12

    5 decls: decls decl .

    $default  reduce using rule 5 (decls)


State 13

    7 decl: type . varlist SEMICOLON
    8     | type . varlist

    error  shift, and go to state 17
    IDENT  shift, and go to state 18

    varlist  go to state 19
    vardef   go to state 20


State 14

   11 decl: error SEMICOLON .

    $default  reduce using rule 11 (decl)


State 15

    9 decl: CONST type . IDENT BECOMES NUMBER SEMICOLON
   10     | CONST type . IDENT BECOMES trueorfalse SEMICOLON

    IDENT  shift, and go to state 21


State 16

    4 block: LBRACE @1 decls $@2 procdecls . stmts RBRACE
   21 procdecls: procdecls . procdecl

    PROC  shift, and go to state 22

    $default  reduce using rule 30 (stmts)

    procdecl  go to state 23
    stmts     go to state 24


State 17

   17 varlist: error . $@3 SEMICOLON
   19 vardef: error . SEMICOLON

    SEMICOLON  shift, and go to state 25

    SEMICOLON  [reduce using rule 16 ($@3)]

    $@3  go to state 26


State 18

   18 vardef: IDENT .

    $default  reduce using rule 18 (vardef)


State 19

    7 decl: type varlist . SEMICOLON
    8     | type varlist .
   15 varlist: varlist . COMMA vardef

    COMMA      shift, and go to state 27
    SEMICOLON  shift, and go to state 28

    $default  reduce using rule 8 (decl)


State 20

   14 varlist: vardef .

    $default  reduce using rule 14 (varlist)


State 21

    9 decl: CONST type IDENT . BECOMES NUMBER SEMICOLON
   10     | CONST type IDENT . BECOMES trueorfalse SEMICOLON

    BECOMES  shift, and go to state 29


State 22

   23 procdecl: PROC . IDENT LPAREN RPAREN get_cx $@4 procbody get_cx

    IDENT  shift, and go to state 30


State 23

   21 procdecls: procdecls procdecl .

    $default  reduce using rule 21 (procdecls)


State 24

    4 block: LBRACE @1 decls $@2 procdecls stmts . RBRACE
   29 stmts: stmts . stm

    error   shift, and go to state 31
    IF      shift, and go to state 32
    WHILE   shift, and go to state 33
    WRITE   shift, and go to state 34
    READ    shift, and go to state 35
    CALL    shift, and go to state 36
    LBRACE  shift, and go to state 37
    RBRACE  shift, and go to state 38
    REPEAT  shift, and go to state 39
    SWITCH  shift, and go to state 40
    EXIT    shift, and go to state 41
    FOR     shift, and go to state 42
    DO      shift, and go to state 43
    IDENT   shift, and go to state 44

    stm              go to state 45
    callstm          go to state 46
    blockstm         go to state 47
    switchstm        go to state 48
    aselfaddorminus  go to state 49
    ident            go to state 50


State 25

   19 vardef: error SEMICOLON .

    $default  reduce using rule 19 (vardef)


State 26

   17 varlist: error $@3 . SEMICOLON

    SEMICOLON  shift, and go to state 51


State 27

   15 varlist: varlist COMMA . vardef

    error  shift, and go to state 52
    IDENT  shift, and go to state 18

    vardef  go to state 53


State 28

    7 decl: type varlist SEMICOLON .

    $default  reduce using rule 7 (decl)


State 29

    9 decl: CONST type IDENT BECOMES . NUMBER SEMICOLON
   10     | CONST type IDENT BECOMES . trueorfalse SEMICOLON

    SYM_TRUE   shift, and go to state 54
    SYM_FALSE  shift, and go to state 55
    NUMBER     shift, and go to state 56

    trueorfalse  go to state 57


State 30

   23 procdecl: PROC IDENT . LPAREN RPAREN get_cx $@4 procbody get_cx

    LPAREN  shift, and go to state 58


State 31

   54 stm: error . $@17 SEMICOLON

    $default  reduce using rule 53 ($@17)

    $@17  go to state 59


State 32

   38 stm: IF . LPAREN bexpr RPAREN get_cx $@11 stm elsestm

    LPAREN  shift, and go to state 60


State 33

   40 stm: WHILE . get_cx LPAREN bexpr RPAREN get_cx $@12 stm

    $default  reduce using rule 115 (get_cx)

    get_cx  go to state 61


State 34

   36 stm: WRITE . aexpr $@10 SEMICOLON

    PLUS    shift, and go to state 62
    MINUS   shift, and go to state 63
    LPAREN  shift, and go to state 64
    IDENT   shift, and go to state 44
    NUMBER  shift, and go to state 65

    idornum          go to state 66
    aexpr            go to state 67
    aterm            go to state 68
    afactor          go to state 69
    abasic           go to state 70
    aselfaddorminus  go to state 71
    ident            go to state 72


State 35

   34 stm: READ . ident $@9 SEMICOLON

    IDENT  shift, and go to state 44

    ident  go to state 73


State 36

   55 callstm: CALL . ident SEMICOLON

    IDENT  shift, and go to state 44

    ident  go to state 74


State 37

   60 blockstm: LBRACE . inc_level $@18 decls $@19 stmts $@20 RBRACE $@21 dec_level

    $default  reduce using rule 117 (inc_level)

    inc_level  go to state 75


State 38

    4 block: LBRACE @1 decls $@2 procdecls stmts RBRACE .

    $default  reduce using rule 4 (block)


State 39

   41 stm: REPEAT . get_cx stm UNTIL LPAREN bexpr RPAREN get_cx SEMICOLON

    $default  reduce using rule 115 (get_cx)

    get_cx  go to state 76


State 40

   72 switchstm: SWITCH . get_cx $@23 LPAREN aexpr RPAREN LBRACE casestms defaultstm RBRACE

    $default  reduce using rule 115 (get_cx)

    get_cx  go to state 77


State 41

   49 stm: EXIT . NUMBER SEMICOLON

    NUMBER  shift, and go to state 78


State 42

   48 stm: FOR . LPAREN fordecl get_cx forbexpr $@14 SEMICOLON get_cx $@15 get_cx forstm RPAREN $@16 get_cx stm

    LPAREN  shift, and go to state 79


State 43

   43 stm: DO . get_cx stm get_cx WHILE LPAREN bexpr get_cx $@13 RPAREN SEMICOLON

    $default  reduce using rule 115 (get_cx)

    get_cx  go to state 80


State 44

  114 ident: IDENT .

    $default  reduce using rule 114 (ident)


State 45

   29 stmts: stmts stm .

    $default  reduce using rule 29 (stmts)


State 46

   52 stm: callstm .

    $default  reduce using rule 52 (stm)


State 47

   51 stm: blockstm .

    $default  reduce using rule 51 (stm)


State 48

   44 stm: switchstm .

    $default  reduce using rule 44 (stm)


State 49

   50 stm: aselfaddorminus . SEMICOLON

    SEMICOLON  shift, and go to state 81


State 50

   31 stm: ident . BECOMES aexpr SEMICOLON
   32    | ident . BECOMES trueorfalse SEMICOLON
  112 aselfaddorminus: ident . SELFADD
  113                | ident . SELFMINUS

    BECOMES    shift, and go to state 82
    SELFADD    shift, and go to state 83
    SELFMINUS  shift, and go to state 84


State 51

   17 varlist: error $@3 SEMICOLON .

    $default  reduce using rule 17 (varlist)


State 52

   19 vardef: error . SEMICOLON

    SEMICOLON  shift, and go to state 25


State 53

   15 varlist: varlist COMMA vardef .

    $default  reduce using rule 15 (varlist)


State 54

   96 trueorfalse: SYM_TRUE .

    $default  reduce using rule 96 (trueorfalse)


State 55

   97 trueorfalse: SYM_FALSE .

    $default  reduce using rule 97 (trueorfalse)


State 56

    9 decl: CONST type IDENT BECOMES NUMBER . SEMICOLON

    SEMICOLON  shift, and go to state 85


State 57

   10 decl: CONST type IDENT BECOMES trueorfalse . SEMICOLON

    SEMICOLON  shift, and go to state 86


State 58

   23 procdecl: PROC IDENT LPAREN . RPAREN get_cx $@4 procbody get_cx

    RPAREN  shift, and go to state 87


State 59

   54 stm: error $@17 . SEMICOLON

    SEMICOLON  shift, and go to state 88


State 60

   38 stm: IF LPAREN . bexpr RPAREN get_cx $@11 stm elsestm

    NOT        shift, and go to state 89
    LPAREN     shift, and go to state 90
    SYM_TRUE   shift, and go to state 54
    SYM_FALSE  shift, and go to state 55
    ODD        shift, and go to state 91
    IDENT      shift, and go to state 44
    NUMBER     shift, and go to state 65

    bexpr        go to state 92
    bterm        go to state 93
    bfactor      go to state 94
    rel          go to state 95
    idornum      go to state 96
    trueorfalse  go to state 97
    ident        go to state 98


State 61

   40 stm: WHILE get_cx . LPAREN bexpr RPAREN get_cx $@12 stm

    LPAREN  shift, and go to state 99


State 62

   98 aexpr: PLUS . aterm

    LPAREN  shift, and go to state 64
    IDENT   shift, and go to state 44
    NUMBER  shift, and go to state 65

    idornum          go to state 66
    aterm            go to state 100
    afactor          go to state 69
    abasic           go to state 70
    aselfaddorminus  go to state 71
    ident            go to state 72


State 63

   99 aexpr: MINUS . aterm

    LPAREN  shift, and go to state 64
    IDENT   shift, and go to state 44
    NUMBER  shift, and go to state 65

    idornum          go to state 66
    aterm            go to state 101
    afactor          go to state 69
    abasic           go to state 70
    aselfaddorminus  go to state 71
    ident            go to state 72


State 64

  110 abasic: LPAREN . aexpr RPAREN

    PLUS    shift, and go to state 62
    MINUS   shift, and go to state 63
    LPAREN  shift, and go to state 64
    IDENT   shift, and go to state 44
    NUMBER  shift, and go to state 65

    idornum          go to state 66
    aexpr            go to state 102
    aterm            go to state 68
    afactor          go to state 69
    abasic           go to state 70
    aselfaddorminus  go to state 71
    ident            go to state 72


State 65

   95 idornum: NUMBER .

    $default  reduce using rule 95 (idornum)


State 66

  109 abasic: idornum .

    $default  reduce using rule 109 (abasic)


State 67

   36 stm: WRITE aexpr . $@10 SEMICOLON
  101 aexpr: aexpr . PLUS aterm
  102      | aexpr . MINUS aterm

    PLUS   shift, and go to state 103
    MINUS  shift, and go to state 104

    $default  reduce using rule 35 ($@10)

    $@10  go to state 105


State 68

  100 aexpr: aterm .
  104 aterm: aterm . TIMES afactor
  105      | aterm . SLASH afactor
  106      | aterm . MOD afactor

    TIMES  shift, and go to state 106
    SLASH  shift, and go to state 107
    MOD    shift, and go to state 108

    $default  reduce using rule 100 (aexpr)


State 69

  103 aterm: afactor .
  108 afactor: afactor . XOR abasic

    XOR  shift, and go to state 109

    $default  reduce using rule 103 (aterm)


State 70

  107 afactor: abasic .

    $default  reduce using rule 107 (afactor)


State 71

  111 abasic: aselfaddorminus .

    $default  reduce using rule 111 (abasic)


State 72

   94 idornum: ident .
  112 aselfaddorminus: ident . SELFADD
  113                | ident . SELFMINUS

    SELFADD    shift, and go to state 83
    SELFMINUS  shift, and go to state 84

    $default  reduce using rule 94 (idornum)


State 73

   34 stm: READ ident . $@9 SEMICOLON

    $default  reduce using rule 33 ($@9)

    $@9  go to state 110


State 74

   55 callstm: CALL ident . SEMICOLON

    SEMICOLON  shift, and go to state 111


State 75

   60 blockstm: LBRACE inc_level . $@18 decls $@19 stmts $@20 RBRACE $@21 dec_level

    $default  reduce using rule 56 ($@18)

    $@18  go to state 112


State 76

   41 stm: REPEAT get_cx . stm UNTIL LPAREN bexpr RPAREN get_cx SEMICOLON

    error   shift, and go to state 31
    IF      shift, and go to state 32
    WHILE   shift, and go to state 33
    WRITE   shift, and go to state 34
    READ    shift, and go to state 35
    CALL    shift, and go to state 36
    LBRACE  shift, and go to state 37
    REPEAT  shift, and go to state 39
    SWITCH  shift, and go to state 40
    EXIT    shift, and go to state 41
    FOR     shift, and go to state 42
    DO      shift, and go to state 43
    IDENT   shift, and go to state 44

    stm              go to state 113
    callstm          go to state 46
    blockstm         go to state 47
    switchstm        go to state 48
    aselfaddorminus  go to state 49
    ident            go to state 50


State 77

   72 switchstm: SWITCH get_cx . $@23 LPAREN aexpr RPAREN LBRACE casestms defaultstm RBRACE

    $default  reduce using rule 71 ($@23)

    $@23  go to state 114


State 78

   49 stm: EXIT NUMBER . SEMICOLON

    SEMICOLON  shift, and go to state 115


State 79

   48 stm: FOR LPAREN . fordecl get_cx forbexpr $@14 SEMICOLON get_cx $@15 get_cx forstm RPAREN $@16 get_cx stm

    IDENT  shift, and go to state 44

    IDENT     [reduce using rule 61 (fordecl)]
    $default  reduce using rule 61 (fordecl)

    fordecl  go to state 116
    ident    go to state 117


State 80

   43 stm: DO get_cx . stm get_cx WHILE LPAREN bexpr get_cx $@13 RPAREN SEMICOLON

    error   shift, and go to state 31
    IF      shift, and go to state 32
    WHILE   shift, and go to state 33
    WRITE   shift, and go to state 34
    READ    shift, and go to state 35
    CALL    shift, and go to state 36
    LBRACE  shift, and go to state 37
    REPEAT  shift, and go to state 39
    SWITCH  shift, and go to state 40
    EXIT    shift, and go to state 41
    FOR     shift, and go to state 42
    DO      shift, and go to state 43
    IDENT   shift, and go to state 44

    stm              go to state 118
    callstm          go to state 46
    blockstm         go to state 47
    switchstm        go to state 48
    aselfaddorminus  go to state 49
    ident            go to state 50


State 81

   50 stm: aselfaddorminus SEMICOLON .

    $default  reduce using rule 50 (stm)


State 82

   31 stm: ident BECOMES . aexpr SEMICOLON
   32    | ident BECOMES . trueorfalse SEMICOLON

    PLUS       shift, and go to state 62
    MINUS      shift, and go to state 63
    LPAREN     shift, and go to state 64
    SYM_TRUE   shift, and go to state 54
    SYM_FALSE  shift, and go to state 55
    IDENT      shift, and go to state 44
    NUMBER     shift, and go to state 65

    idornum          go to state 66
    trueorfalse      go to state 119
    aexpr            go to state 120
    aterm            go to state 68
    afactor          go to state 69
    abasic           go to state 70
    aselfaddorminus  go to state 71
    ident            go to state 72


State 83

  112 aselfaddorminus: ident SELFADD .

    $default  reduce using rule 112 (aselfaddorminus)


State 84

  113 aselfaddorminus: ident SELFMINUS .

    $default  reduce using rule 113 (aselfaddorminus)


State 85

    9 decl: CONST type IDENT BECOMES NUMBER SEMICOLON .

    $default  reduce using rule 9 (decl)


State 86

   10 decl: CONST type IDENT BECOMES trueorfalse SEMICOLON .

    $default  reduce using rule 10 (decl)


State 87

   23 procdecl: PROC IDENT LPAREN RPAREN . get_cx $@4 procbody get_cx

    $default  reduce using rule 115 (get_cx)

    get_cx  go to state 121


State 88

   54 stm: error $@17 SEMICOLON .

    $default  reduce using rule 54 (stm)


State 89

   84 bfactor: NOT . bfactor

    NOT        shift, and go to state 89
    LPAREN     shift, and go to state 90
    SYM_TRUE   shift, and go to state 54
    SYM_FALSE  shift, and go to state 55
    ODD        shift, and go to state 91
    IDENT      shift, and go to state 44
    NUMBER     shift, and go to state 65

    bfactor      go to state 122
    rel          go to state 95
    idornum      go to state 96
    trueorfalse  go to state 97
    ident        go to state 98


State 90

   85 bfactor: LPAREN . bexpr RPAREN

    NOT        shift, and go to state 89
    LPAREN     shift, and go to state 90
    SYM_TRUE   shift, and go to state 54
    SYM_FALSE  shift, and go to state 55
    ODD        shift, and go to state 91
    IDENT      shift, and go to state 44
    NUMBER     shift, and go to state 65

    bexpr        go to state 123
    bterm        go to state 93
    bfactor      go to state 94
    rel          go to state 95
    idornum      go to state 96
    trueorfalse  go to state 97
    ident        go to state 98


State 91

   86 bfactor: ODD . LPAREN idornum RPAREN

    LPAREN  shift, and go to state 124


State 92

   38 stm: IF LPAREN bexpr . RPAREN get_cx $@11 stm elsestm
   78 bexpr: bexpr . OR bterm

    OR      shift, and go to state 125
    RPAREN  shift, and go to state 126


State 93

   79 bexpr: bterm .
   80 bterm: bterm . AND bfactor

    AND  shift, and go to state 127

    $default  reduce using rule 79 (bexpr)


State 94

   81 bterm: bfactor .

    $default  reduce using rule 81 (bterm)


State 95

   87 bfactor: rel .

    $default  reduce using rule 87 (bfactor)


State 96

   88 rel: idornum . EQL aexpr
   89    | idornum . NEQ aexpr
   90    | idornum . LES aexpr
   91    | idornum . LEQ aexpr
   92    | idornum . GTR aexpr
   93    | idornum . GEQ aexpr

    LES  shift, and go to state 128
    LEQ  shift, and go to state 129
    GTR  shift, and go to state 130
    GEQ  shift, and go to state 131
    EQL  shift, and go to state 132
    NEQ  shift, and go to state 133


State 97

   83 bfactor: trueorfalse .

    $default  reduce using rule 83 (bfactor)


State 98

   82 bfactor: ident .
   94 idornum: ident .

    OR         reduce using rule 82 (bfactor)
    AND        reduce using rule 82 (bfactor)
    SEMICOLON  reduce using rule 82 (bfactor)
    RPAREN     reduce using rule 82 (bfactor)
    $default   reduce using rule 94 (idornum)


State 99

   40 stm: WHILE get_cx LPAREN . bexpr RPAREN get_cx $@12 stm

    NOT        shift, and go to state 89
    LPAREN     shift, and go to state 90
    SYM_TRUE   shift, and go to state 54
    SYM_FALSE  shift, and go to state 55
    ODD        shift, and go to state 91
    IDENT      shift, and go to state 44
    NUMBER     shift, and go to state 65

    bexpr        go to state 134
    bterm        go to state 93
    bfactor      go to state 94
    rel          go to state 95
    idornum      go to state 96
    trueorfalse  go to state 97
    ident        go to state 98


State 100

   98 aexpr: PLUS aterm .
  104 aterm: aterm . TIMES afactor
  105      | aterm . SLASH afactor
  106      | aterm . MOD afactor

    TIMES  shift, and go to state 106
    SLASH  shift, and go to state 107
    MOD    shift, and go to state 108

    $default  reduce using rule 98 (aexpr)


State 101

   99 aexpr: MINUS aterm .
  104 aterm: aterm . TIMES afactor
  105      | aterm . SLASH afactor
  106      | aterm . MOD afactor

    TIMES  shift, and go to state 106
    SLASH  shift, and go to state 107
    MOD    shift, and go to state 108

    $default  reduce using rule 99 (aexpr)


State 102

  101 aexpr: aexpr . PLUS aterm
  102      | aexpr . MINUS aterm
  110 abasic: LPAREN aexpr . RPAREN

    PLUS    shift, and go to state 103
    MINUS   shift, and go to state 104
    RPAREN  shift, and go to state 135


State 103

  101 aexpr: aexpr PLUS . aterm

    LPAREN  shift, and go to state 64
    IDENT   shift, and go to state 44
    NUMBER  shift, and go to state 65

    idornum          go to state 66
    aterm            go to state 136
    afactor          go to state 69
    abasic           go to state 70
    aselfaddorminus  go to state 71
    ident            go to state 72


State 104

  102 aexpr: aexpr MINUS . aterm

    LPAREN  shift, and go to state 64
    IDENT   shift, and go to state 44
    NUMBER  shift, and go to state 65

    idornum          go to state 66
    aterm            go to state 137
    afactor          go to state 69
    abasic           go to state 70
    aselfaddorminus  go to state 71
    ident            go to state 72


State 105

   36 stm: WRITE aexpr $@10 . SEMICOLON

    SEMICOLON  shift, and go to state 138


State 106

  104 aterm: aterm TIMES . afactor

    LPAREN  shift, and go to state 64
    IDENT   shift, and go to state 44
    NUMBER  shift, and go to state 65

    idornum          go to state 66
    afactor          go to state 139
    abasic           go to state 70
    aselfaddorminus  go to state 71
    ident            go to state 72


State 107

  105 aterm: aterm SLASH . afactor

    LPAREN  shift, and go to state 64
    IDENT   shift, and go to state 44
    NUMBER  shift, and go to state 65

    idornum          go to state 66
    afactor          go to state 140
    abasic           go to state 70
    aselfaddorminus  go to state 71
    ident            go to state 72


State 108

  106 aterm: aterm MOD . afactor

    LPAREN  shift, and go to state 64
    IDENT   shift, and go to state 44
    NUMBER  shift, and go to state 65

    idornum          go to state 66
    afactor          go to state 141
    abasic           go to state 70
    aselfaddorminus  go to state 71
    ident            go to state 72


State 109

  108 afactor: afactor XOR . abasic

    LPAREN  shift, and go to state 64
    IDENT   shift, and go to state 44
    NUMBER  shift, and go to state 65

    idornum          go to state 66
    abasic           go to state 142
    aselfaddorminus  go to state 71
    ident            go to state 72


State 110

   34 stm: READ ident $@9 . SEMICOLON

    SEMICOLON  shift, and go to state 143


State 111

   55 callstm: CALL ident SEMICOLON .

    $default  reduce using rule 55 (callstm)


State 112

   60 blockstm: LBRACE inc_level $@18 . decls $@19 stmts $@20 RBRACE $@21 dec_level

    $default  reduce using rule 6 (decls)

    decls  go to state 144


State 113

   41 stm: REPEAT get_cx stm . UNTIL LPAREN bexpr RPAREN get_cx SEMICOLON

    UNTIL  shift, and go to state 145


State 114

   72 switchstm: SWITCH get_cx $@23 . LPAREN aexpr RPAREN LBRACE casestms defaultstm RBRACE

    LPAREN  shift, and go to state 146


State 115

   49 stm: EXIT NUMBER SEMICOLON .

    $default  reduce using rule 49 (stm)


State 116

   48 stm: FOR LPAREN fordecl . get_cx forbexpr $@14 SEMICOLON get_cx $@15 get_cx forstm RPAREN $@16 get_cx stm

    $default  reduce using rule 115 (get_cx)

    get_cx  go to state 147


State 117

   62 fordecl: ident . BECOMES aexpr SEMICOLON
   63        | ident . BECOMES bexpr SEMICOLON

    BECOMES  shift, and go to state 148


State 118

   43 stm: DO get_cx stm . get_cx WHILE LPAREN bexpr get_cx $@13 RPAREN SEMICOLON

    $default  reduce using rule 115 (get_cx)

    get_cx  go to state 149


State 119

   32 stm: ident BECOMES trueorfalse . SEMICOLON

    SEMICOLON  shift, and go to state 150


State 120

   31 stm: ident BECOMES aexpr . SEMICOLON
  101 aexpr: aexpr . PLUS aterm
  102      | aexpr . MINUS aterm

    PLUS       shift, and go to state 103
    MINUS      shift, and go to state 104
    SEMICOLON  shift, and go to state 151


State 121

   23 procdecl: PROC IDENT LPAREN RPAREN get_cx . $@4 procbody get_cx

    $default  reduce using rule 22 ($@4)

    $@4  go to state 152


State 122

   84 bfactor: NOT bfactor .

    $default  reduce using rule 84 (bfactor)


State 123

   78 bexpr: bexpr . OR bterm
   85 bfactor: LPAREN bexpr . RPAREN

    OR      shift, and go to state 125
    RPAREN  shift, and go to state 153


State 124

   86 bfactor: ODD LPAREN . idornum RPAREN

    IDENT   shift, and go to state 44
    NUMBER  shift, and go to state 65

    idornum  go to state 154
    ident    go to state 155


State 125

   78 bexpr: bexpr OR . bterm

    NOT        shift, and go to state 89
    LPAREN     shift, and go to state 90
    SYM_TRUE   shift, and go to state 54
    SYM_FALSE  shift, and go to state 55
    ODD        shift, and go to state 91
    IDENT      shift, and go to state 44
    NUMBER     shift, and go to state 65

    bterm        go to state 156
    bfactor      go to state 94
    rel          go to state 95
    idornum      go to state 96
    trueorfalse  go to state 97
    ident        go to state 98


State 126

   38 stm: IF LPAREN bexpr RPAREN . get_cx $@11 stm elsestm

    $default  reduce using rule 115 (get_cx)

    get_cx  go to state 157


State 127

   80 bterm: bterm AND . bfactor

    NOT        shift, and go to state 89
    LPAREN     shift, and go to state 90
    SYM_TRUE   shift, and go to state 54
    SYM_FALSE  shift, and go to state 55
    ODD        shift, and go to state 91
    IDENT      shift, and go to state 44
    NUMBER     shift, and go to state 65

    bfactor      go to state 158
    rel          go to state 95
    idornum      go to state 96
    trueorfalse  go to state 97
    ident        go to state 98


State 128

   90 rel: idornum LES . aexpr

    PLUS    shift, and go to state 62
    MINUS   shift, and go to state 63
    LPAREN  shift, and go to state 64
    IDENT   shift, and go to state 44
    NUMBER  shift, and go to state 65

    idornum          go to state 66
    aexpr            go to state 159
    aterm            go to state 68
    afactor          go to state 69
    abasic           go to state 70
    aselfaddorminus  go to state 71
    ident            go to state 72


State 129

   91 rel: idornum LEQ . aexpr

    PLUS    shift, and go to state 62
    MINUS   shift, and go to state 63
    LPAREN  shift, and go to state 64
    IDENT   shift, and go to state 44
    NUMBER  shift, and go to state 65

    idornum          go to state 66
    aexpr            go to state 160
    aterm            go to state 68
    afactor          go to state 69
    abasic           go to state 70
    aselfaddorminus  go to state 71
    ident            go to state 72


State 130

   92 rel: idornum GTR . aexpr

    PLUS    shift, and go to state 62
    MINUS   shift, and go to state 63
    LPAREN  shift, and go to state 64
    IDENT   shift, and go to state 44
    NUMBER  shift, and go to state 65

    idornum          go to state 66
    aexpr            go to state 161
    aterm            go to state 68
    afactor          go to state 69
    abasic           go to state 70
    aselfaddorminus  go to state 71
    ident            go to state 72


State 131

   93 rel: idornum GEQ . aexpr

    PLUS    shift, and go to state 62
    MINUS   shift, and go to state 63
    LPAREN  shift, and go to state 64
    IDENT   shift, and go to state 44
    NUMBER  shift, and go to state 65

    idornum          go to state 66
    aexpr            go to state 162
    aterm            go to state 68
    afactor          go to state 69
    abasic           go to state 70
    aselfaddorminus  go to state 71
    ident            go to state 72


State 132

   88 rel: idornum EQL . aexpr

    PLUS    shift, and go to state 62
    MINUS   shift, and go to state 63
    LPAREN  shift, and go to state 64
    IDENT   shift, and go to state 44
    NUMBER  shift, and go to state 65

    idornum          go to state 66
    aexpr            go to state 163
    aterm            go to state 68
    afactor          go to state 69
    abasic           go to state 70
    aselfaddorminus  go to state 71
    ident            go to state 72


State 133

   89 rel: idornum NEQ . aexpr

    PLUS    shift, and go to state 62
    MINUS   shift, and go to state 63
    LPAREN  shift, and go to state 64
    IDENT   shift, and go to state 44
    NUMBER  shift, and go to state 65

    idornum          go to state 66
    aexpr            go to state 164
    aterm            go to state 68
    afactor          go to state 69
    abasic           go to state 70
    aselfaddorminus  go to state 71
    ident            go to state 72


State 134

   40 stm: WHILE get_cx LPAREN bexpr . RPAREN get_cx $@12 stm
   78 bexpr: bexpr . OR bterm

    OR      shift, and go to state 125
    RPAREN  shift, and go to state 165


State 135

  110 abasic: LPAREN aexpr RPAREN .

    $default  reduce using rule 110 (abasic)


State 136

  101 aexpr: aexpr PLUS aterm .
  104 aterm: aterm . TIMES afactor
  105      | aterm . SLASH afactor
  106      | aterm . MOD afactor

    TIMES  shift, and go to state 106
    SLASH  shift, and go to state 107
    MOD    shift, and go to state 108

    $default  reduce using rule 101 (aexpr)


State 137

  102 aexpr: aexpr MINUS aterm .
  104 aterm: aterm . TIMES afactor
  105      | aterm . SLASH afactor
  106      | aterm . MOD afactor

    TIMES  shift, and go to state 106
    SLASH  shift, and go to state 107
    MOD    shift, and go to state 108

    $default  reduce using rule 102 (aexpr)


State 138

   36 stm: WRITE aexpr $@10 SEMICOLON .

    $default  reduce using rule 36 (stm)


State 139

  104 aterm: aterm TIMES afactor .
  108 afactor: afactor . XOR abasic

    XOR  shift, and go to state 109

    $default  reduce using rule 104 (aterm)


State 140

  105 aterm: aterm SLASH afactor .
  108 afactor: afactor . XOR abasic

    XOR  shift, and go to state 109

    $default  reduce using rule 105 (aterm)


State 141

  106 aterm: aterm MOD afactor .
  108 afactor: afactor . XOR abasic

    XOR  shift, and go to state 109

    $default  reduce using rule 106 (aterm)


State 142

  108 afactor: afactor XOR abasic .

    $default  reduce using rule 108 (afactor)


State 143

   34 stm: READ ident $@9 SEMICOLON .

    $default  reduce using rule 34 (stm)


State 144

    5 decls: decls . decl
   60 blockstm: LBRACE inc_level $@18 decls . $@19 stmts $@20 RBRACE $@21 dec_level

    error  shift, and go to state 7
    INT    shift, and go to state 8
    BOOL   shift, and go to state 9
    CONST  shift, and go to state 10

    error   [reduce using rule 57 ($@19)]
    IF      reduce using rule 57 ($@19)
    WHILE   reduce using rule 57 ($@19)
    WRITE   reduce using rule 57 ($@19)
    READ    reduce using rule 57 ($@19)
    CALL    reduce using rule 57 ($@19)
    LBRACE  reduce using rule 57 ($@19)
    RBRACE  reduce using rule 57 ($@19)
    REPEAT  reduce using rule 57 ($@19)
    SWITCH  reduce using rule 57 ($@19)
    EXIT    reduce using rule 57 ($@19)
    FOR     reduce using rule 57 ($@19)
    DO      reduce using rule 57 ($@19)
    IDENT   reduce using rule 57 ($@19)

    decl  go to state 12
    type  go to state 13
    $@19  go to state 166


State 145

   41 stm: REPEAT get_cx stm UNTIL . LPAREN bexpr RPAREN get_cx SEMICOLON

    LPAREN  shift, and go to state 167


State 146

   72 switchstm: SWITCH get_cx $@23 LPAREN . aexpr RPAREN LBRACE casestms defaultstm RBRACE

    PLUS    shift, and go to state 62
    MINUS   shift, and go to state 63
    LPAREN  shift, and go to state 64
    IDENT   shift, and go to state 44
    NUMBER  shift, and go to state 65

    idornum          go to state 66
    aexpr            go to state 168
    aterm            go to state 68
    afactor          go to state 69
    abasic           go to state 70
    aselfaddorminus  go to state 71
    ident            go to state 72


State 147

   48 stm: FOR LPAREN fordecl get_cx . forbexpr $@14 SEMICOLON get_cx $@15 get_cx forstm RPAREN $@16 get_cx stm

    NOT        shift, and go to state 89
    LPAREN     shift, and go to state 90
    SYM_TRUE   shift, and go to state 54
    SYM_FALSE  shift, and go to state 55
    ODD        shift, and go to state 91
    IDENT      shift, and go to state 44
    NUMBER     shift, and go to state 65

    $default  reduce using rule 66 (forbexpr)

    forbexpr     go to state 169
    bexpr        go to state 170
    bterm        go to state 93
    bfactor      go to state 94
    rel          go to state 95
    idornum      go to state 96
    trueorfalse  go to state 97
    ident        go to state 98


State 148

   62 fordecl: ident BECOMES . aexpr SEMICOLON
   63        | ident BECOMES . bexpr SEMICOLON

    PLUS       shift, and go to state 62
    MINUS      shift, and go to state 63
    NOT        shift, and go to state 89
    LPAREN     shift, and go to state 171
    SYM_TRUE   shift, and go to state 54
    SYM_FALSE  shift, and go to state 55
    ODD        shift, and go to state 91
    IDENT      shift, and go to state 44
    NUMBER     shift, and go to state 65

    bexpr            go to state 172
    bterm            go to state 93
    bfactor          go to state 94
    rel              go to state 95
    idornum          go to state 173
    trueorfalse      go to state 97
    aexpr            go to state 174
    aterm            go to state 68
    afactor          go to state 69
    abasic           go to state 70
    aselfaddorminus  go to state 71
    ident            go to state 175


State 149

   43 stm: DO get_cx stm get_cx . WHILE LPAREN bexpr get_cx $@13 RPAREN SEMICOLON

    WHILE  shift, and go to state 176


State 150

   32 stm: ident BECOMES trueorfalse SEMICOLON .

    $default  reduce using rule 32 (stm)


State 151

   31 stm: ident BECOMES aexpr SEMICOLON .

    $default  reduce using rule 31 (stm)


State 152

   23 procdecl: PROC IDENT LPAREN RPAREN get_cx $@4 . procbody get_cx

    LBRACE  shift, and go to state 177

    procbody  go to state 178


State 153

   85 bfactor: LPAREN bexpr RPAREN .

    $default  reduce using rule 85 (bfactor)


State 154

   86 bfactor: ODD LPAREN idornum . RPAREN

    RPAREN  shift, and go to state 179


State 155

   94 idornum: ident .

    $default  reduce using rule 94 (idornum)


State 156

   78 bexpr: bexpr OR bterm .
   80 bterm: bterm . AND bfactor

    AND  shift, and go to state 127

    $default  reduce using rule 78 (bexpr)


State 157

   38 stm: IF LPAREN bexpr RPAREN get_cx . $@11 stm elsestm

    $default  reduce using rule 37 ($@11)

    $@11  go to state 180


State 158

   80 bterm: bterm AND bfactor .

    $default  reduce using rule 80 (bterm)


State 159

   90 rel: idornum LES aexpr .
  101 aexpr: aexpr . PLUS aterm
  102      | aexpr . MINUS aterm

    PLUS   shift, and go to state 103
    MINUS  shift, and go to state 104

    $default  reduce using rule 90 (rel)


State 160

   91 rel: idornum LEQ aexpr .
  101 aexpr: aexpr . PLUS aterm
  102      | aexpr . MINUS aterm

    PLUS   shift, and go to state 103
    MINUS  shift, and go to state 104

    $default  reduce using rule 91 (rel)


State 161

   92 rel: idornum GTR aexpr .
  101 aexpr: aexpr . PLUS aterm
  102      | aexpr . MINUS aterm

    PLUS   shift, and go to state 103
    MINUS  shift, and go to state 104

    $default  reduce using rule 92 (rel)


State 162

   93 rel: idornum GEQ aexpr .
  101 aexpr: aexpr . PLUS aterm
  102      | aexpr . MINUS aterm

    PLUS   shift, and go to state 103
    MINUS  shift, and go to state 104

    $default  reduce using rule 93 (rel)


State 163

   88 rel: idornum EQL aexpr .
  101 aexpr: aexpr . PLUS aterm
  102      | aexpr . MINUS aterm

    PLUS   shift, and go to state 103
    MINUS  shift, and go to state 104

    $default  reduce using rule 88 (rel)


State 164

   89 rel: idornum NEQ aexpr .
  101 aexpr: aexpr . PLUS aterm
  102      | aexpr . MINUS aterm

    PLUS   shift, and go to state 103
    MINUS  shift, and go to state 104

    $default  reduce using rule 89 (rel)


State 165

   40 stm: WHILE get_cx LPAREN bexpr RPAREN . get_cx $@12 stm

    $default  reduce using rule 115 (get_cx)

    get_cx  go to state 181


State 166

   60 blockstm: LBRACE inc_level $@18 decls $@19 . stmts $@20 RBRACE $@21 dec_level

    $default  reduce using rule 30 (stmts)

    stmts  go to state 182


State 167

   41 stm: REPEAT get_cx stm UNTIL LPAREN . bexpr RPAREN get_cx SEMICOLON

    NOT        shift, and go to state 89
    LPAREN     shift, and go to state 90
    SYM_TRUE   shift, and go to state 54
    SYM_FALSE  shift, and go to state 55
    ODD        shift, and go to state 91
    IDENT      shift, and go to state 44
    NUMBER     shift, and go to state 65

    bexpr        go to state 183
    bterm        go to state 93
    bfactor      go to state 94
    rel          go to state 95
    idornum      go to state 96
    trueorfalse  go to state 97
    ident        go to state 98


State 168

   72 switchstm: SWITCH get_cx $@23 LPAREN aexpr . RPAREN LBRACE casestms defaultstm RBRACE
  101 aexpr: aexpr . PLUS aterm
  102      | aexpr . MINUS aterm

    PLUS    shift, and go to state 103
    MINUS   shift, and go to state 104
    RPAREN  shift, and go to state 184


State 169

   48 stm: FOR LPAREN fordecl get_cx forbexpr . $@14 SEMICOLON get_cx $@15 get_cx forstm RPAREN $@16 get_cx stm

    $default  reduce using rule 45 ($@14)

    $@14  go to state 185


State 170

   67 forbexpr: bexpr .
   78 bexpr: bexpr . OR bterm

    OR  shift, and go to state 125

    $default  reduce using rule 67 (forbexpr)


State 171

   85 bfactor: LPAREN . bexpr RPAREN
  110 abasic: LPAREN . aexpr RPAREN

    PLUS       shift, and go to state 62
    MINUS      shift, and go to state 63
    NOT        shift, and go to state 89
    LPAREN     shift, and go to state 171
    SYM_TRUE   shift, and go to state 54
    SYM_FALSE  shift, and go to state 55
    ODD        shift, and go to state 91
    IDENT      shift, and go to state 44
    NUMBER     shift, and go to state 65

    bexpr            go to state 123
    bterm            go to state 93
    bfactor          go to state 94
    rel              go to state 95
    idornum          go to state 173
    trueorfalse      go to state 97
    aexpr            go to state 102
    aterm            go to state 68
    afactor          go to state 69
    abasic           go to state 70
    aselfaddorminus  go to state 71
    ident            go to state 175


State 172

   63 fordecl: ident BECOMES bexpr . SEMICOLON
   78 bexpr: bexpr . OR bterm

    OR         shift, and go to state 125
    SEMICOLON  shift, and go to state 186


State 173

   88 rel: idornum . EQL aexpr
   89    | idornum . NEQ aexpr
   90    | idornum . LES aexpr
   91    | idornum . LEQ aexpr
   92    | idornum . GTR aexpr
   93    | idornum . GEQ aexpr
  109 abasic: idornum .

    LES  shift, and go to state 128
    LEQ  shift, and go to state 129
    GTR  shift, and go to state 130
    GEQ  shift, and go to state 131
    EQL  shift, and go to state 132
    NEQ  shift, and go to state 133

    $default  reduce using rule 109 (abasic)


State 174

   62 fordecl: ident BECOMES aexpr . SEMICOLON
  101 aexpr: aexpr . PLUS aterm
  102      | aexpr . MINUS aterm

    PLUS       shift, and go to state 103
    MINUS      shift, and go to state 104
    SEMICOLON  shift, and go to state 187


State 175

   82 bfactor: ident .
   94 idornum: ident .
  112 aselfaddorminus: ident . SELFADD
  113                | ident . SELFMINUS

    SELFADD    shift, and go to state 83
    SELFMINUS  shift, and go to state 84

    OR         reduce using rule 82 (bfactor)
    AND        reduce using rule 82 (bfactor)
    SEMICOLON  reduce using rule 82 (bfactor)
    SEMICOLON  [reduce using rule 94 (idornum)]
    RPAREN     reduce using rule 82 (bfactor)
    RPAREN     [reduce using rule 94 (idornum)]
    $default   reduce using rule 94 (idornum)


State 176

   43 stm: DO get_cx stm get_cx WHILE . LPAREN bexpr get_cx $@13 RPAREN SEMICOLON

    LPAREN  shift, and go to state 188


State 177

   28 procbody: LBRACE . inc_level $@5 get_table_addr decls $@6 stmts $@7 RBRACE $@8 dec_level

    $default  reduce using rule 117 (inc_level)

    inc_level  go to state 189


State 178

   23 procdecl: PROC IDENT LPAREN RPAREN get_cx $@4 procbody . get_cx

    $default  reduce using rule 115 (get_cx)

    get_cx  go to state 190


State 179

   86 bfactor: ODD LPAREN idornum RPAREN .

    $default  reduce using rule 86 (bfactor)


State 180

   38 stm: IF LPAREN bexpr RPAREN get_cx $@11 . stm elsestm

    error   shift, and go to state 31
    IF      shift, and go to state 32
    WHILE   shift, and go to state 33
    WRITE   shift, and go to state 34
    READ    shift, and go to state 35
    CALL    shift, and go to state 36
    LBRACE  shift, and go to state 37
    REPEAT  shift, and go to state 39
    SWITCH  shift, and go to state 40
    EXIT    shift, and go to state 41
    FOR     shift, and go to state 42
    DO      shift, and go to state 43
    IDENT   shift, and go to state 44

    stm              go to state 191
    callstm          go to state 46
    blockstm         go to state 47
    switchstm        go to state 48
    aselfaddorminus  go to state 49
    ident            go to state 50


State 181

   40 stm: WHILE get_cx LPAREN bexpr RPAREN get_cx . $@12 stm

    $default  reduce using rule 39 ($@12)

    $@12  go to state 192


State 182

   29 stmts: stmts . stm
   60 blockstm: LBRACE inc_level $@18 decls $@19 stmts . $@20 RBRACE $@21 dec_level

    error   shift, and go to state 31
    IF      shift, and go to state 32
    WHILE   shift, and go to state 33
    WRITE   shift, and go to state 34
    READ    shift, and go to state 35
    CALL    shift, and go to state 36
    LBRACE  shift, and go to state 37
    REPEAT  shift, and go to state 39
    SWITCH  shift, and go to state 40
    EXIT    shift, and go to state 41
    FOR     shift, and go to state 42
    DO      shift, and go to state 43
    IDENT   shift, and go to state 44

    RBRACE  reduce using rule 58 ($@20)

    stm              go to state 45
    callstm          go to state 46
    blockstm         go to state 47
    $@20             go to state 193
    switchstm        go to state 48
    aselfaddorminus  go to state 49
    ident            go to state 50


State 183

   41 stm: REPEAT get_cx stm UNTIL LPAREN bexpr . RPAREN get_cx SEMICOLON
   78 bexpr: bexpr . OR bterm

    OR      shift, and go to state 125
    RPAREN  shift, and go to state 194


State 184

   72 switchstm: SWITCH get_cx $@23 LPAREN aexpr RPAREN . LBRACE casestms defaultstm RBRACE

    LBRACE  shift, and go to state 195


State 185

   48 stm: FOR LPAREN fordecl get_cx forbexpr $@14 . SEMICOLON get_cx $@15 get_cx forstm RPAREN $@16 get_cx stm

    SEMICOLON  shift, and go to state 196


State 186

   63 fordecl: ident BECOMES bexpr SEMICOLON .

    $default  reduce using rule 63 (fordecl)


State 187

   62 fordecl: ident BECOMES aexpr SEMICOLON .

    $default  reduce using rule 62 (fordecl)


State 188

   43 stm: DO get_cx stm get_cx WHILE LPAREN . bexpr get_cx $@13 RPAREN SEMICOLON

    NOT        shift, and go to state 89
    LPAREN     shift, and go to state 90
    SYM_TRUE   shift, and go to state 54
    SYM_FALSE  shift, and go to state 55
    ODD        shift, and go to state 91
    IDENT      shift, and go to state 44
    NUMBER     shift, and go to state 65

    bexpr        go to state 197
    bterm        go to state 93
    bfactor      go to state 94
    rel          go to state 95
    idornum      go to state 96
    trueorfalse  go to state 97
    ident        go to state 98


State 189

   28 procbody: LBRACE inc_level . $@5 get_table_addr decls $@6 stmts $@7 RBRACE $@8 dec_level

    $default  reduce using rule 24 ($@5)

    $@5  go to state 198


State 190

   23 procdecl: PROC IDENT LPAREN RPAREN get_cx $@4 procbody get_cx .

    $default  reduce using rule 23 (procdecl)


State 191

   38 stm: IF LPAREN bexpr RPAREN get_cx $@11 stm . elsestm

    ELSE  shift, and go to state 199

    $default  reduce using rule 68 (elsestm)

    elsestm  go to state 200


State 192

   40 stm: WHILE get_cx LPAREN bexpr RPAREN get_cx $@12 . stm

    error   shift, and go to state 31
    IF      shift, and go to state 32
    WHILE   shift, and go to state 33
    WRITE   shift, and go to state 34
    READ    shift, and go to state 35
    CALL    shift, and go to state 36
    LBRACE  shift, and go to state 37
    REPEAT  shift, and go to state 39
    SWITCH  shift, and go to state 40
    EXIT    shift, and go to state 41
    FOR     shift, and go to state 42
    DO      shift, and go to state 43
    IDENT   shift, and go to state 44

    stm              go to state 201
    callstm          go to state 46
    blockstm         go to state 47
    switchstm        go to state 48
    aselfaddorminus  go to state 49
    ident            go to state 50


State 193

   60 blockstm: LBRACE inc_level $@18 decls $@19 stmts $@20 . RBRACE $@21 dec_level

    RBRACE  shift, and go to state 202


State 194

   41 stm: REPEAT get_cx stm UNTIL LPAREN bexpr RPAREN . get_cx SEMICOLON

    $default  reduce using rule 115 (get_cx)

    get_cx  go to state 203


State 195

   72 switchstm: SWITCH get_cx $@23 LPAREN aexpr RPAREN LBRACE . casestms defaultstm RBRACE

    $default  reduce using rule 73 (casestms)

    casestms  go to state 204


State 196

   48 stm: FOR LPAREN fordecl get_cx forbexpr $@14 SEMICOLON . get_cx $@15 get_cx forstm RPAREN $@16 get_cx stm

    $default  reduce using rule 115 (get_cx)

    get_cx  go to state 205


State 197

   43 stm: DO get_cx stm get_cx WHILE LPAREN bexpr . get_cx $@13 RPAREN SEMICOLON
   78 bexpr: bexpr . OR bterm

    OR  shift, and go to state 125

    $default  reduce using rule 115 (get_cx)

    get_cx  go to state 206


State 198

   28 procbody: LBRACE inc_level $@5 . get_table_addr decls $@6 stmts $@7 RBRACE $@8 dec_level

    $default  reduce using rule 116 (get_table_addr)

    get_table_addr  go to state 207


State 199

   70 elsestm: ELSE . get_cx $@22 stm

    $default  reduce using rule 115 (get_cx)

    get_cx  go to state 208


State 200

   38 stm: IF LPAREN bexpr RPAREN get_cx $@11 stm elsestm .

    $default  reduce using rule 38 (stm)


State 201

   40 stm: WHILE get_cx LPAREN bexpr RPAREN get_cx $@12 stm .

    $default  reduce using rule 40 (stm)


State 202

   60 blockstm: LBRACE inc_level $@18 decls $@19 stmts $@20 RBRACE . $@21 dec_level

    $default  reduce using rule 59 ($@21)

    $@21  go to state 209


State 203

   41 stm: REPEAT get_cx stm UNTIL LPAREN bexpr RPAREN get_cx . SEMICOLON

    SEMICOLON  shift, and go to state 210


State 204

   72 switchstm: SWITCH get_cx $@23 LPAREN aexpr RPAREN LBRACE casestms . defaultstm RBRACE
   74 casestms: casestms . casestm

    CASE     shift, and go to state 211
    DEFAULT  shift, and go to state 212

    casestm     go to state 213
    defaultstm  go to state 214


State 205

   48 stm: FOR LPAREN fordecl get_cx forbexpr $@14 SEMICOLON get_cx . $@15 get_cx forstm RPAREN $@16 get_cx stm

    $default  reduce using rule 46 ($@15)

    $@15  go to state 215


State 206

   43 stm: DO get_cx stm get_cx WHILE LPAREN bexpr get_cx . $@13 RPAREN SEMICOLON

    $default  reduce using rule 42 ($@13)

    $@13  go to state 216


State 207

   28 procbody: LBRACE inc_level $@5 get_table_addr . decls $@6 stmts $@7 RBRACE $@8 dec_level

    $default  reduce using rule 6 (decls)

    decls  go to state 217


State 208

   70 elsestm: ELSE get_cx . $@22 stm

    $default  reduce using rule 69 ($@22)

    $@22  go to state 218


State 209

   60 blockstm: LBRACE inc_level $@18 decls $@19 stmts $@20 RBRACE $@21 . dec_level

    $default  reduce using rule 118 (dec_level)

    dec_level  go to state 219


State 210

   41 stm: REPEAT get_cx stm UNTIL LPAREN bexpr RPAREN get_cx SEMICOLON .

    $default  reduce using rule 41 (stm)


State 211

   76 casestm: CASE . aexpr get_cx $@24 COLON stm

    PLUS    shift, and go to state 62
    MINUS   shift, and go to state 63
    LPAREN  shift, and go to state 64
    IDENT   shift, and go to state 44
    NUMBER  shift, and go to state 65

    idornum          go to state 66
    aexpr            go to state 220
    aterm            go to state 68
    afactor          go to state 69
    abasic           go to state 70
    aselfaddorminus  go to state 71
    ident            go to state 72


State 212

   77 defaultstm: DEFAULT . COLON get_cx stm

    COLON  shift, and go to state 221


State 213

   74 casestms: casestms casestm .

    $default  reduce using rule 74 (casestms)


State 214

   72 switchstm: SWITCH get_cx $@23 LPAREN aexpr RPAREN LBRACE casestms defaultstm . RBRACE

    RBRACE  shift, and go to state 222


State 215

   48 stm: FOR LPAREN fordecl get_cx forbexpr $@14 SEMICOLON get_cx $@15 . get_cx forstm RPAREN $@16 get_cx stm

    $default  reduce using rule 115 (get_cx)

    get_cx  go to state 223


State 216

   43 stm: DO get_cx stm get_cx WHILE LPAREN bexpr get_cx $@13 . RPAREN SEMICOLON

    RPAREN  shift, and go to state 224


State 217

    5 decls: decls . decl
   28 procbody: LBRACE inc_level $@5 get_table_addr decls . $@6 stmts $@7 RBRACE $@8 dec_level

    error  shift, and go to state 7
    INT    shift, and go to state 8
    BOOL   shift, and go to state 9
    CONST  shift, and go to state 10

    error   [reduce using rule 25 ($@6)]
    IF      reduce using rule 25 ($@6)
    WHILE   reduce using rule 25 ($@6)
    WRITE   reduce using rule 25 ($@6)
    READ    reduce using rule 25 ($@6)
    CALL    reduce using rule 25 ($@6)
    LBRACE  reduce using rule 25 ($@6)
    RBRACE  reduce using rule 25 ($@6)
    REPEAT  reduce using rule 25 ($@6)
    SWITCH  reduce using rule 25 ($@6)
    EXIT    reduce using rule 25 ($@6)
    FOR     reduce using rule 25 ($@6)
    DO      reduce using rule 25 ($@6)
    IDENT   reduce using rule 25 ($@6)

    decl  go to state 12
    type  go to state 13
    $@6   go to state 225


State 218

   70 elsestm: ELSE get_cx $@22 . stm

    error   shift, and go to state 31
    IF      shift, and go to state 32
    WHILE   shift, and go to state 33
    WRITE   shift, and go to state 34
    READ    shift, and go to state 35
    CALL    shift, and go to state 36
    LBRACE  shift, and go to state 37
    REPEAT  shift, and go to state 39
    SWITCH  shift, and go to state 40
    EXIT    shift, and go to state 41
    FOR     shift, and go to state 42
    DO      shift, and go to state 43
    IDENT   shift, and go to state 44

    stm              go to state 226
    callstm          go to state 46
    blockstm         go to state 47
    switchstm        go to state 48
    aselfaddorminus  go to state 49
    ident            go to state 50


State 219

   60 blockstm: LBRACE inc_level $@18 decls $@19 stmts $@20 RBRACE $@21 dec_level .

    $default  reduce using rule 60 (blockstm)


State 220

   76 casestm: CASE aexpr . get_cx $@24 COLON stm
  101 aexpr: aexpr . PLUS aterm
  102      | aexpr . MINUS aterm

    PLUS   shift, and go to state 103
    MINUS  shift, and go to state 104

    $default  reduce using rule 115 (get_cx)

    get_cx  go to state 227


State 221

   77 defaultstm: DEFAULT COLON . get_cx stm

    $default  reduce using rule 115 (get_cx)

    get_cx  go to state 228


State 222

   72 switchstm: SWITCH get_cx $@23 LPAREN aexpr RPAREN LBRACE casestms defaultstm RBRACE .

    $default  reduce using rule 72 (switchstm)


State 223

   48 stm: FOR LPAREN fordecl get_cx forbexpr $@14 SEMICOLON get_cx $@15 get_cx . forstm RPAREN $@16 get_cx stm

    PLUS    shift, and go to state 62
    MINUS   shift, and go to state 63
    LPAREN  shift, and go to state 64
    IDENT   shift, and go to state 44
    NUMBER  shift, and go to state 65

    $default  reduce using rule 64 (forstm)

    forstm           go to state 229
    idornum          go to state 66
    aexpr            go to state 230
    aterm            go to state 68
    afactor          go to state 69
    abasic           go to state 70
    aselfaddorminus  go to state 71
    ident            go to state 72


State 224

   43 stm: DO get_cx stm get_cx WHILE LPAREN bexpr get_cx $@13 RPAREN . SEMICOLON

    SEMICOLON  shift, and go to state 231


State 225

   28 procbody: LBRACE inc_level $@5 get_table_addr decls $@6 . stmts $@7 RBRACE $@8 dec_level

    $default  reduce using rule 30 (stmts)

    stmts  go to state 232


State 226

   70 elsestm: ELSE get_cx $@22 stm .

    $default  reduce using rule 70 (elsestm)


State 227

   76 casestm: CASE aexpr get_cx . $@24 COLON stm

    $default  reduce using rule 75 ($@24)

    $@24  go to state 233


State 228

   77 defaultstm: DEFAULT COLON get_cx . stm

    error   shift, and go to state 31
    IF      shift, and go to state 32
    WHILE   shift, and go to state 33
    WRITE   shift, and go to state 34
    READ    shift, and go to state 35
    CALL    shift, and go to state 36
    LBRACE  shift, and go to state 37
    REPEAT  shift, and go to state 39
    SWITCH  shift, and go to state 40
    EXIT    shift, and go to state 41
    FOR     shift, and go to state 42
    DO      shift, and go to state 43
    IDENT   shift, and go to state 44

    stm              go to state 234
    callstm          go to state 46
    blockstm         go to state 47
    switchstm        go to state 48
    aselfaddorminus  go to state 49
    ident            go to state 50


State 229

   48 stm: FOR LPAREN fordecl get_cx forbexpr $@14 SEMICOLON get_cx $@15 get_cx forstm . RPAREN $@16 get_cx stm

    RPAREN  shift, and go to state 235


State 230

   65 forstm: aexpr .
  101 aexpr: aexpr . PLUS aterm
  102      | aexpr . MINUS aterm

    PLUS   shift, and go to state 103
    MINUS  shift, and go to state 104

    $default  reduce using rule 65 (forstm)


State 231

   43 stm: DO get_cx stm get_cx WHILE LPAREN bexpr get_cx $@13 RPAREN SEMICOLON .

    $default  reduce using rule 43 (stm)


State 232

   28 procbody: LBRACE inc_level $@5 get_table_addr decls $@6 stmts . $@7 RBRACE $@8 dec_level
   29 stmts: stmts . stm

    error   shift, and go to state 31
    IF      shift, and go to state 32
    WHILE   shift, and go to state 33
    WRITE   shift, and go to state 34
    READ    shift, and go to state 35
    CALL    shift, and go to state 36
    LBRACE  shift, and go to state 37
    REPEAT  shift, and go to state 39
    SWITCH  shift, and go to state 40
    EXIT    shift, and go to state 41
    FOR     shift, and go to state 42
    DO      shift, and go to state 43
    IDENT   shift, and go to state 44

    RBRACE  reduce using rule 26 ($@7)

    $@7              go to state 236
    stm              go to state 45
    callstm          go to state 46
    blockstm         go to state 47
    switchstm        go to state 48
    aselfaddorminus  go to state 49
    ident            go to state 50


State 233

   76 casestm: CASE aexpr get_cx $@24 . COLON stm

    COLON  shift, and go to state 237


State 234

   77 defaultstm: DEFAULT COLON get_cx stm .

    $default  reduce using rule 77 (defaultstm)


State 235

   48 stm: FOR LPAREN fordecl get_cx forbexpr $@14 SEMICOLON get_cx $@15 get_cx forstm RPAREN . $@16 get_cx stm

    $default  reduce using rule 47 ($@16)

    $@16  go to state 238


State 236

   28 procbody: LBRACE inc_level $@5 get_table_addr decls $@6 stmts $@7 . RBRACE $@8 dec_level

    RBRACE  shift, and go to state 239


State 237

   76 casestm: CASE aexpr get_cx $@24 COLON . stm

    error   shift, and go to state 31
    IF      shift, and go to state 32
    WHILE   shift, and go to state 33
    WRITE   shift, and go to state 34
    READ    shift, and go to state 35
    CALL    shift, and go to state 36
    LBRACE  shift, and go to state 37
    REPEAT  shift, and go to state 39
    SWITCH  shift, and go to state 40
    EXIT    shift, and go to state 41
    FOR     shift, and go to state 42
    DO      shift, and go to state 43
    IDENT   shift, and go to state 44

    stm              go to state 240
    callstm          go to state 46
    blockstm         go to state 47
    switchstm        go to state 48
    aselfaddorminus  go to state 49
    ident            go to state 50


State 238

   48 stm: FOR LPAREN fordecl get_cx forbexpr $@14 SEMICOLON get_cx $@15 get_cx forstm RPAREN $@16 . get_cx stm

    $default  reduce using rule 115 (get_cx)

    get_cx  go to state 241


State 239

   28 procbody: LBRACE inc_level $@5 get_table_addr decls $@6 stmts $@7 RBRACE . $@8 dec_level

    $default  reduce using rule 27 ($@8)

    $@8  go to state 242


State 240

   76 casestm: CASE aexpr get_cx $@24 COLON stm .

    $default  reduce using rule 76 (casestm)


State 241

   48 stm: FOR LPAREN fordecl get_cx forbexpr $@14 SEMICOLON get_cx $@15 get_cx forstm RPAREN $@16 get_cx . stm

    error   shift, and go to state 31
    IF      shift, and go to state 32
    WHILE   shift, and go to state 33
    WRITE   shift, and go to state 34
    READ    shift, and go to state 35
    CALL    shift, and go to state 36
    LBRACE  shift, and go to state 37
    REPEAT  shift, and go to state 39
    SWITCH  shift, and go to state 40
    EXIT    shift, and go to state 41
    FOR     shift, and go to state 42
    DO      shift, and go to state 43
    IDENT   shift, and go to state 44

    stm              go to state 243
    callstm          go to state 46
    blockstm         go to state 47
    switchstm        go to state 48
    aselfaddorminus  go to state 49
    ident            go to state 50


State 242

   28 procbody: LBRACE inc_level $@5 get_table_addr decls $@6 stmts $@7 RBRACE $@8 . dec_level

    $default  reduce using rule 118 (dec_level)

    dec_level  go to state 244


State 243

   48 stm: FOR LPAREN fordecl get_cx forbexpr $@14 SEMICOLON get_cx $@15 get_cx forstm RPAREN $@16 get_cx stm .

    $default  reduce using rule 48 (stm)


State 244

   28 procbody: LBRACE inc_level $@5 get_table_addr decls $@6 stmts $@7 RBRACE $@8 dec_level .

    $default  reduce using rule 28 (procbody)
